> 우리가 컴포넌트를 나눌때, 어떤 기준이어야 하는가?
> 해당 컴포넌트가 어떤 이유를 가지고 있고, 이유가 여러개라면 나눈다.
> 이유가 작은 이유들로 쪼갤 수 있다면 쪼개지만, 굳이 그럴 필요가 없다면 쪼개지 않는다.
> 굳이 그럴 필요가 없다는 의미는 충분히 나눌 수 있지만, 쪼갠 컴포넌트가 재사용되지 않는다면, 안쪼게는 맞을지도
> 우리는 클래스로 만들지 않고, 커스텀훅을 이용해 모듈화를 한다.
> 로직을 재사용하기 위해(값의 재사용이 아닌)

## 3.1 기이한 이름

함수선언 바꾸기
변수 이름 바꾸기
필드이름 바꾸기

ㅏ땅한 이름이 떠오르지 않는다면 근본적ㅇ니 ㅇ문제

## 3.2 중복 코드
같은 표현식


## 3.3 긴 함수
오랜기간 활용되는 프로그램 -> 짧은 함수로 구성
간접호출 효과
이해하고, 공유하고 선택하기 쉬워진다는 장점

함수가 길수록 이해하기 어렵다.
좋은 이름 + 짧은 함수 => 
함수의 목적(의도)와 구현코드의 괴리가 얾마나 큰가

무엇을 하는지 코드가 잘 설명해주지 못할수록 함수로 만들어야한다.

## 3.4 긴 매개변수 목록
전역변수를 없애기위한 방편이었지만, 긴 매개변수 자체로 이해하기 어려울때가 많다.

## 3.5 전역 데이터
redux, react-query, 
=> 값의 상태에대해 추적하기 어려운 변수 X

변수 캡슐화하기, 
=> 어떻게 변경해야할지, 함수를 만들고, 제한값을 두거나, 에러를 내뱉지 않는 원리로 동작시킨다.
ex)1. useReducer()
ex)2.
```js
// 방어로직을 짤 수 있다.
const setPrice(price) {
  this.price = price < 0 ? 0: price;
}
```
## 3.6 가변 데이터

## 3.7 뒤엉킨 변경(하나의 모듈이 너무 많은 이유를 가지고 있다.)
소프트웨어 구조는 소프트해야한다.
군데를 찾아 그 부분만 수정할 수 있기를 바란다.

[단일 책임 원칙(클래스를 변경하는 이유(Actor)는 단 하나여야한다.)](https://yoongrammer.tistory.com/96#:~:text=%EB%8B%A8%EC%9D%BC%20%EC%B1%85%EC%9E%84%20%EC%9B%90%EC%B9%99(SRP%3A%20Single%20Responsibility%20Principle)%EC%9D%80%20%EB%8B%A4%EC%84%AF,%EC%B1%85%EC%9E%84%EB%A7%8C%20%EA%B0%80%EC%A7%80%EA%B3%A0%20%EC%9E%88%EC%96%B4%EC%95%BC%20%ED%95%A9%EB%8B%88%EB%8B%A4.)

> SRP는 변경으로 버그가 발생하더라도 다른 관련 없는 동작에 영향을 미치지 않도록 동작을 분리하는 것을 목표로 합니다.
> 
클래스나 모듈이 서로 다른 이유로 변경되기 시작한다면 SRP를 따르도록 분리해야 합니다.
>
하지만 SRP에 대한 과도한 고려는 더 나은 설계 대신 이해하기 힘든 설계로 이어질 수 있으니 과도하게 사용하면 안 됩니다.


컴포넌트, 컴포넌트가 가져야하는 상태는 단 1개?
하나의 여러개의 이유로 변경되어야 하는 컴포넌트는 없어야한다.
하나의 이유가 넓게 퍼져잇는 화면이라면? 컴포넌트가 커질 수도 있을것

랜딩페이지의 경우 그렇게 컴포넌트화 시키지 않아도 될 수 있다.
회원가입, 도 마찬가지

## 3.8 산탄총 수술(하나의 이유가 너무 많은 모듈에 퍼져있다.)
> 전역변수 사용도 비슷한 이유 아닐까?
> 이런 이유로, 전역변수가 변경될 수 잇는 형태를 제한함으로서 최소한의 안전장치느낌?

## 3.9 기능 편애
함수가, 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용을 많이 할 때
자주 엮여지는곳 근처에 둔다.

하지만 앞서 이야기한 규칙을 거스르는 패턴도 있다. 전략패턴, 방문자 패턴, 자기 위임
> 코드의 구조를 수정하는 이유에따라, 전혀다른 패턴을 적요애향할 떄가 있을 것


## 3.10 데이터 뭉치

## 3.11 기본형 집착
## 3.12 반복되는 switch문
모든 스위치 -> 조건부 로직을 다형성으로 바꾸기?
> 우리는 좀더 다형성을 넣을 필요는 없는지 고민해봐야하지 않을까 싶다.
> 프론트 코드도 클래스를 사용할 일이 있으면 좋겠다.
## 3.13 반복문
일급함수, 파이프라인으로 바꾸기
장점: 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소
본문 코드를 그대로 쓰는것과 진배없는 함수도 잇고,
실질적으로 메서드가 하나뿐인 클래스도 있다.
> 우리도 컴포넌트가 의미없이 나눠지는 형태는 피해야한다.

## 3.15 추측성 일반화
'나중에 필요할 거야'
> 아직 우리에게 적용하긴 먼 미래 아닐까?

## 3.16 임시 필드
특정 상황에서만 값이 설정되는 필드를 가진 클래스가 잇다.
하지만 보통 객체를 가져올 때, 모든 필드가 채워져 있으리라 시대하는게 보통이다.
클래스 추출하기나, 특이케이스 추가하기로 별도의 클래스로 분리하여 사용하는 입장에서 오해의 소지를 없애준다.

## 3.17 메시지 체인
다른 객체를 요청하는 작어빙 연쇄적으로 이어지는 코드
-> 위임 숨기기

## 3.18 중개자
## 3.19 내부자 거래
결합도와 응집도,

## 3.20 거대한 클래스

## 3.21 서로 다른 인터페이스의 대안 클래스
교체하려면, 같은 인터페이스르가져야한다.
> 커스텀훅이 가능 인터페이스를 가졌는지 어떻게 보자?
> 타입 스크립트의 인터페이스나 타입을 통해 리턴구조같으면 가능
> 리턴타입은 인터페이스로 해야할까?

## 3.22 데이터 클래스
## 3.23 상속 포기
## 3.24 주석
-> 장황한 주석은 잘못된 프로그래밍이라는 표시일 수 있다.
